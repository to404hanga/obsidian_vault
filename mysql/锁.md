## 全局锁

### 全局锁怎么用

要使用全局锁，则要执行这条命令：

```sql
flush tables with read lock;
```

执行后，整个数据库就处于 **只读** 状态了

如果要释放全局锁，则要执行这条命令：

```sql
unlock tables;
```

当然，会话断开了，全局锁会被自动释放

### 全局锁的应用场景

主要应用于 **全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样

### 加全局锁会带来什么缺点

加上全局锁，意味着整个数据库都是只读状态

那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞

### 有什么方式可以避免

如果数据库的引擎支持的事务支持 **[可重复读](事务)** 的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作

备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 `–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持可重复读隔离级别的事务的存储引擎

## 表级锁

### 表锁

如果想对学生表（t_student）加表锁，可以使用这些命令：

```sql
// 表级别的共享锁，也就是读锁
lock tables t_student read;

// 表级别的独占锁，也就是写锁
lock tables t_student write;
```

需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。也就是说如果本线程对学生表加了 **共享表锁**，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放

要释放表锁，可以使用下面的命令，释放当前会话的所有表锁：

```sql
unlock tables;
```

另外，当会话退出后，也会释放所有表锁

### 元数据锁

也叫 MDL，不需要显式的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：

1. 对一张表做 CRUD 操作时，加的是 MDL 读锁
2. 对一张表做结构变更操作时，加的是 MDL 写锁

MDL 在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的

申请 MDL 锁的操作会形成一个队列，队列中 **写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作

所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更

### 意向锁

1. 在使用 InnoDB 引擎的表里对某些记录加上 **共享锁** 之前，需要先在表级别加上一个 **意向共享锁**
2. 在使用 InnoDB 引擎的表里对某些记录加上 **独占锁** 之前，需要先在表级别加上一个 **意向独占锁**

也就是，当执行插入、更新、删除操作，需要先对表加上 **意向共享锁**，然后对该记录加独占锁

普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的

不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：

```sql
// 先在表上加上意向共享锁，然后对读取的记录加独占锁
select ... lock in share mode;

// 先在表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和 **共享表锁**（`lock tables ... read`）和 **独占表锁**（`lock tables ... write`）发生冲突

表锁和行锁是满足读读共享、读写互斥、写写互斥的

如果没有意向锁，那么加独占表锁时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢

那么有了意向锁，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加独占表锁时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录

所以，**意向锁的目的是为了快速判断表里是否有记录被加锁**

### AUTO-INC 锁

在为某个字段声明 `AUTO_INCREMENT` 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的

AUTO-INC 锁是特殊的表锁机制，锁不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放

在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 `AUTO_INCREMENT` 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉

那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 `AUTO_INCREMENT` 修饰的字段的值是连续递增的

但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞

因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种 **轻量级的锁** 来实现自增

一样也是在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁

InnoDB 存储引擎提供了个 `innodb_autoinc_lock_mode` 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁

1. 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁
2. 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁
3. 当 innodb_autoinc_lock_mode = 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁

不过，当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，**这在有主从复制的场景中是不安全的**

## 行级锁

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁

1. **Record Lock**，记录锁，也就是仅仅把一条记录锁上
2. **Gap Lock**，间隙锁，锁定一个范围，但是不包含记录本身，**前开后开区间**
3. **Next-Key Lock**，记录锁 + 间隙锁的组合，锁定一个范围及记录本身，**前开后闭区间**

### 唯一索引等值查询

1. 当查询的记录是存在的，在用唯一索引进行等值查询时，next-key lock 会退化为记录锁
2. 当查询的记录是不存在的，在用唯一索引进行等值查询时，next-key lock 会退化为间隙锁

### 唯一索引范围查询

### 非唯一索引等值查询

1. 当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁
2. 当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁

### 非唯一索引范围查询

普通索引范围查询，next-key lock 不会退化为间隙锁和记录锁