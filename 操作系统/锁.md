## 互斥锁与自旋锁

最底层的两种锁——**互斥锁** 和 **自旋锁**，有很多高级的锁都是基于它们实现的

当已经有一个线程加锁后，其他线程加锁就会失败，互斥锁和自旋锁对于加锁失败后的处理方式不一样：

1. 互斥锁加锁失败后，线程会 **释放 CPU**，给其他线程
2. 自旋锁加锁失败后，线程会 **忙等待**，直到它拿到锁

### 互斥锁

互斥锁是一种 **独占锁**，当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞

对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，内核会将线程置为 **睡眠** 状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行

所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本——**两次 [线程上下文切换](进程和线程#线程上下文切换) 的成本**：

1. 当线程加锁失败时，内核会把线程的状态从 **运行** 状态设置为 **睡眠** 状态，然后把 CPU 切换给其他线程运行
2. 接着，当锁被释放时，之前 **睡眠** 状态的线程会变为 **就绪** 状态，然后内核会在合适的时间，把 CPU 切换给该线程运行

所以，**如果能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用 [自旋锁](#自旋锁)，否则使用互斥锁**

### 自旋锁

自旋锁是通过 CPU 提供的 `CAS` 函数（_Compare And Swap_），在 **用户态** 完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。加锁的步骤如下：

1. 查看锁的状态，如果锁是空闲的，执行 `2`
2. 将锁设置为当前线程持有

`CAS` 函数把这两个步骤合并为一条硬件级指令，形成 **原子指令**

使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会 **忙等待**，直到它拿到锁。这里的 **忙等待** 可以用 `while` 循环等待实现，不过最好是使用 CPU 提供的 `PAUSE` 指令来实现 **忙等待**，因为可以减少循环等待时的耗电量

自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。**需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU**

自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成 **正比** 的关系

## 读写锁

由 **读锁** 和 **写锁** 两部分组成，如果只读取共享资源用读锁加锁，如果要修改共享资源则用写锁加锁。所以，读写锁适用于能明确区分读操作和写操作的场景

工作原理：

1. 当 **写锁** 没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为 **读锁** 是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据
2. 但是，一旦 **写锁** 被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞

所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似 [互斥锁](#互斥锁) 和 [自旋锁](#自旋锁)，而读锁是共享锁，因为读锁可以被多个线程同时持有

可以发现，**读写锁在读多写少的场景，能发挥出优势**。另外，根据实现的不同，读写锁可以分为 **[读优先锁](#读优先锁)** 和 **[写优先锁](#写优先锁)**

### 读优先锁

读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取读锁

读优先锁对于读线程并发性更好，但如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程 **饥饿** 的现象

### 写优先锁

写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁

写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被 **饿死**

### 公平读写锁

公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现 **饥饿** 的现象

## 乐观锁与悲观锁

### 悲观锁

[互斥锁](#互斥锁)、[自旋锁](#自旋锁)、[读写锁](#读写锁) 都是属于悲观锁

悲观锁认为，**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，要先上锁**

### 乐观锁

乐观锁假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。可以发现，乐观锁全程没有加锁，所以也叫 **无锁编程**

乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以 **只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁**
