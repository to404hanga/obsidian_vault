当 Redis 的运行内存已经超过 Redis 设定的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效运行

## 如何设置 Redis 最大运行内存

在配置文件 redis.conf 中，可以通过参数 maxmemory \<bytes\> 来设定最大运行内存，只有在 Redis 的运行内存达到了设置的最大运行内存，才会触发内存淘汰策略

不同位数的操作系统，maxmemory 的默认值是不同的：

1. 在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存限制，无论用户存放多少数据到 Redis 中，也不会对可用内存进行检查，直到 Redis 实例崩溃也无作为
2. 在 32 位操作系统中，maxmemory 的默认值是 3 G，因为 32 位的机器最大只支持 4 GB 的内存，而系统本身就需要一定的内存资源来支持运行

## Redis 内存淘汰策略有哪些

1. 不进行数据淘汰的策略
	1. **noeviction**（Redis 3.0 之后，默认的内存淘汰策略）：表示当运行内存超过最大设置内存时，不淘汰任何内存，而是不再提供服务，直接返回错误
2. 进行数据淘汰的策略
	1. 在设置了过期时间的数据中进行淘汰
		1. **volatile-random**：随机淘汰设置了过期时间的任意键值
		2. **volatile-ttl**：优先淘汰更早过期的键值
		3. **volatile-lru**（Redis 3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值
		4. **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值
	2. 在所有数据范围内进行淘汰
		1. **allkeys-random**：随机淘汰任意键值
		2. **allkeys-lru**：淘汰整个键值中最久未使用的键值
		3. **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值

## 如何查看当前 Redis 使用的内存淘汰策略

```shell
> config get maxmemory-policy
1) "maxmemory-policy"
2) "noeviction"
```

## 如何修改 Redis 的内存淘汰策略

1. 通过 **config get maxmemory-policy \<策略\>** 命令设置。优点是设置后立即生效，不需要重启服务，缺点是重启后设置就会失效
2. 通过修改配置文件，设置 **maxmemory-policy \<策略\>**，优点是重启后配置不会丢失，缺点是重启后才能生效

## LRU 和 LFU 的区别

### LRU

#### 什么是 LRU

LRU 全称是 Least Recently Used 最近最少使用，会选择淘汰最近最少使用的数据

传统 LRU 算法基于 **链表** 结构实现，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除表尾的元素即可。但传统的 LRU 算法存在两个问题：

1. 需要用链表管理所有的缓存数据，会带来额外的空间开销
2. 当有数据被访问时，需要在链表上把该数据移动到表头，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而降低 Redis 缓存性能

#### Redis 如何实现 LRU

Redis 实现的是一种 **近似 LRU 算法**，目的是为了更好地节约内存，实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间

当 Redis 进行内存淘汰时，会使用 **随机采样** 的方式来淘汰数据，随机取 5 个值（可配置），然后淘汰最久没有使用的那个

##### Redis 实现的 LRU 的优点

1. 不用为所有数据维护一个大链表，节省了空间占用
2. 不用在每次数据访问时都移动链表项，提升了缓存性能

但是 LRU 算法 **无法解决缓存污染问题**，比如应用一次读取了大量数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染

### LFU

#### 什么是 LFU

LFU 全称是 Least Frequently Used 最近最不常用，根据数据访问次数淘汰数据，核心思想是如果数据过去被访问多次，那么将来被访问的频率也更高

LFU 会记录每个数据的访问次数，当一个数据被再次访问时，就会增加该数据的访问次数

#### Redis 如何实现 LFU

```C
typedef struct redisObject {
	...
	// 24 bits，用于记录对象的访问信息
	unsigned lru:24;
	...
} robj;
```

Redis 对象头中的 lru 字段，在 LRU 算法和 LFU 算法下使用方式并不相同

1. 在 LRU 算法中，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳
2. 在 LFU 算法中，Redis 对象头的 24 bits 的 lru 字段被分为两段存储，高 16 bit 存储 ldt(Last Decrement Time)，低 8 bit 存储 logc(Logistic Counter)
	1. ldt 是用来记录 key 的访问时间戳
	2. logc 是用来记录 key 的访问频次，值越小表示使用频率越低，越容易被淘汰，每个新加入的 key 的 logc 初始值为 5，**logc 会随时间推移而衰减**

Redis 在访问 key 时，对于 logc 是这样变化的：

1. 先按照上次访问距离当前的时长，对 logc 进行衰减
2. 然后再按照一定概率增加 logc 的值

redis.conf 提供两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：

1. **lfu-decay-time**：用于调整 logc 的衰减速度，以分钟为单位，默认值为 1，lfu-decay-time 值越大，衰减越慢
2. **lfu-log-factor**：用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢