Redis 的 SET 命令有个 NX 参数可以实现 **key 不存在才插入**，所以可以用于实现分布式锁

1. 如果 key 不存在，则显示插入成功，可以用来表示加锁成功
2. 如果 key 存在，则会显示插入失败，可以用来表示加锁失败

基于 Redis 实现分布式锁时，对于加锁操作，需要满足三个条件：

1. 加锁包括了读取锁变量、检查锁变量值盒设置锁变量值三个操作，但需要以原子操作的方式完成，所以需要使用 SET 命令带上 NX 选项实现加锁
2. 锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以需要在 SET 命令执行时加上 EX/PX 选项，设置其过期时间
3. 锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端

满足这三个条件的分布式命令如下：

```shell
SET lock_key unique_value NX PX 10000
```

而解锁的过程就是将 lock_key 键删除（del lock_key），但不能乱删，必须保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除

```lua
// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
if redis.call("get", KEYS[1]) == ARGV[1] then
	return redis.call("del", KEYS[1])
else
	return 0
end
```

基于 Redis 实现分布式锁的优点：

1. 性能高效
2. 实现方便
3. 避免单点故障

基于 Redis 实现分布式锁的缺点：

1. 超时时间不好设置：可以基于 **续约** 的方式设置超时时间，先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置锁的超时时间，当主线程执行完成后，销毁续约锁即可
2. Redis 主从复制模式中的数据是异步复制的，导致分布式锁的不可靠性

如何解决集群情况下分布式锁的可靠性？

**Redlock**（红锁），基于多个 Redis 节点的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作

基本思路是，让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么就可以认为加锁成功，否则加锁失败。过程如下：

1. 客户端获取当前时间（t1）
2. 客户端依次向 N 个 Redis 节点执行加锁操作
	1. 加锁使用 SET 命令，带上 NX、EX/PX 选项，以及带上客户端的唯一标识
	2. 如果某个 Redis 节点发生故障，需要给 **加锁操作** 设置一个超时时间
3. 一旦客户端完成了和所有节点的加锁操作，客户端就要计算整个加锁过程的总耗时（t2）

加锁成功要同时满足两个条件：

1. 客户端从超过半数的 Redis 节点上成功获取锁
2. 客户端获取锁的总耗时（t2）没有超过锁的有效时间

加锁成功后，客户端需要重新计算锁的有效时间，计算的结果是锁的最初有效时间减去加锁的总耗时

加锁失败后，客户端向所有 Redis 节点发起释放锁的操作