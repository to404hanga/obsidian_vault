## string

底层实现为 int 和 [SDS](数据结构#SDS)，value 最多可以容纳的数据长度是 **512M**

字符串对象的内部编码有 3 种：

1. int 对应 int 数据结构
2. raw 对应 SDS 数据结构
3. embstr 对应 SDS 数据结构

### 常用指令

普通字符串的基本操作：

```shell
# 设置 key-value 类型的值
> SET name lin
OK
# 根据 key 获得对应的 value
> GET name
"lin"
# 判断某个 key 是否存在
> EXISTS name
(integer) 1
# 返回 key 所储存的字符串值的长度
> STRLEN name
(integer) 3
# 删除某个 key 对应的值
> DEL name
(integer) 1
```

批量设置：

```shell
# 批量设置 key-value 类型的值
> MSET key1 value1 key2 value2
OK
# 批量获取多个 key 对应的 value
> MGET key1 key2
1) "value1"
2) "value2"
```

计数器（字符串的值为整数的时候可用）：

```shell
# 设置 key-value 类型的值
> SET number 0
OK
# 将 key 中储存的数字值自增 1
> INCR number
(integer) 1
# 将 key 中存储的数字值加 10
> INCRBY number 10
(integer) 11
# 将 key 中存储的数字值自减 1
> DECR number
(integer) 10
# 将 key 中存储的数字值减 10
> DECRBY number 10
(integer) 0
```

过期（默认为永不过期）：

```shell
# 设置 key 在 60 秒后过期（该方法是针对已经存在的 key 设置过期时间）
> EXPIRE name 60
(integer) 1
# 查看数据还有多久过期
> TTL name
(integer) 51
# 设置 key-value 类型的值，并设置该 key 的过期时间为 60 秒
> SET key value EX 60
OK
> SETEX key 60 value
OK
```

不存在就插入：

```shell
# 不存在就插入（not exists）
> SETNX key value
(integer) 1
```

### 应用场景

#### 缓存对象

1. 直接缓存整个对象的 JSON，命令例子：
```shell
SET user:1 '{"name":"xiaolin","age":18}'
```
2. 采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子：
```shell
MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20
```

#### 常规计数

因为 Redis 处理命令是单线程，所以执行命令的过程是原子性的。因此 string 数据类型很适合计数场景，比如计算访问次数、点赞、转发、库存数量等等

比如计算文章的阅读量：

```shell
# 初始化文章的阅读量
> SET article:readcount:1001 0
OK
# 阅读量 + 1
> INCR article:readcount:1001
(integer) 1
# 阅读量 + 1
> INCR article:readcount:1001
(integer) 2
# 阅读量 + 1
> INCR article:readcount:1001
(integer) 3
# 获取对应文章的阅读量
> GET article:readcount:1001
"3"
```

#### 分布式锁

SET 命令有个 NX 参数可以实现 key 不存在才插入，可以用它来实现分布式锁

1. 如果 key 不存在，则显示插入成功，可以用来表示加锁成功
2. 如果 key 存在，则会显示插入失败，可以用来表示加锁失败

一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：

```shell
SET lock_key unique_value NX PX 10000
```

1. lock_key 就是 key 键
2. unique_value 是客户端生成的唯一标识
3. NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作
4. PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁

而解锁的过程就是将 lock_key 键删除，但 **不能乱删**，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，要先判断锁的 unique_value 是否为是否为加锁客户端，是的话才将 lock_key 键删除

需要使用 Lua 脚本来保证解锁的原子性

```lua
// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
if redis.call("get", KEYS[1]) == ARGV[1] then
	return redis.call("del", KEYS[1])
else
	return 0
end
```

## List

列表的最大长度为 2^32 -1，即每个列表支持超过 40 亿个元素

底层实现为 [双向链表](数据结构#双向链表) 或 [压缩列表](数据结构#压缩列表) 

1. 如果列表的元素个数小于 **512** 个（默认值，可由 **list-max-ziplist-entries** 配置），列表每个元素的值都小于 **64** 字节（默认值，可由 **list-max-ziplist-value** 配置），Redis 会使用 **压缩列表** 作为 List 类型的底层数据结构
2. 如果列表的元素不满足上面的条件，redis 会使用 **双向链表** 作为 List 类型的底层数据结构

但在 redis 3.2 版本之后，List 数据类型底层数据结构就只有 quicklist 实现了，替代了双向链表和压缩列表

### 常用命令

```shell
# 将一个或多个值 value 插入到 key 列表的表头（最左边），最后的值在最前面
> LPUSH key value [value ...]
# 将一个或多个值 value 插入到 key 列表的表尾（最右边）
> RPUSH key value [value ...]
# 移除并返回 key 列表的头元素
> LPOP key
# 移除并返回 key 列表的尾元素
> RPOP key
# 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定，从 0 开始
> LRANGE key start stop
# 从 key 列表表头弹出一个元素，没有就阻塞 timeout 秒，如果 timeout=0 则一直阻塞
> BLPOP key [key ...] timeout
# 从 key 列表表尾弹出一个元素，没有就阻塞 timeout 秒，如果 timeout=0 则一直阻塞
> BRPOP key [key ...] timeout
```

### 应用场景

#### 消息队列

消息队列在存取消息时，必须要满足三个需求，分别是 **消息保序**、**处理重复的消息** 和 **保证消息可靠性**

Redis 的 List 和 [Stream](#Stream) 两种数据类型，可以满足消息队列的这三个需求

1. 如何满足消息保序
	使用 LPUSH + RPOP（或者 RPUSH + LPOP）命令实现消息队列。但是存在一个潜在的性能风险点——生产者往 List 中写入数据时，LIst 并不会主动通知消费者有新消息，如果需要消费者想要及时处理消息，就需要消费者不停地调用 RPOP 命令。如果有新消息写入，RPOP 命令就会返回结果，否则，RPOP 命令就会返回空值，再继续循环

	为了解决这个问题，Redis 提供了 BRPOP 命令——阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据
2. 如何处理重复的消息
	消费者要实现重复消息的判断，有两方面的要求：
	1. 每个消息都有一个全局的 ID
	2. 消费者要记录已经处理过的消息的 ID，当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理
	但是 List 并不会为每个消息生成 ID 号，所以需要自行为每个消息生成一个全局唯一 ID，生成之后，在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID
	```shell
	# 将全局 ID 为 111000102、库存量为 99 的消息插入消息队列
	> LPUSH mq "111000102:stock:99"
	(integer) 1
	```
3. 如何保证消息可靠性
	当消费者从 List 中读取一条消息后，List 就不会再留存这条消息了，如果消费者在处理过程中出现了故障或宕机，就会导致消息没有处理完成，消息者重启后就无法再次从 List 中读取消息了

	为了留存消息，List 类型提供了  **BRPOPLPUSH** 命令，让消费者从给一个 List 中读取消息，同时，Redis 会把这个消息再插入另一个 List 留存

但是，在用 List 做消息队列时，如果生产者消息发送很快，而消费者处理消息比较慢，就会导致 List 中的消息越积越多，给 Redis 的内存带来很大压力。需要启动多个消费者程序组成一个消费组，但是 List 类型不支持消费组的实现

## Hash

### 内部实现

Hash 类型的底层数据结构是由 [压缩列表](数据结构#压缩列表) 或 [哈希表](数据结构#哈希表) 实现的

1. 如果哈希类型元素个数小于 **512** 个（默认值，可由 **hash-max-ziplist-entries** 配置），所有值小于 **64** 字节（默认值，可由 **hash-max-ziplist-value** 配置）的话，Redis 会使用压缩列表做为 Hash 类型的底层数据结构
2. 如果哈希类型元素不满足以上条件，Redis 会使用哈希表作为 Hash 类型的底层数据结构

在 Redis 7.0 中，压缩列表数据接哦股已经废弃了，交由 [listpack](数据结构#listpack) 数据结构来实现

### 常用命令

```shell
# 存储一个哈希表 key 的键值
HSET key field value
# 获取哈希表 key 对应 field 键值
HGET key field
# 在一个哈希表 key 中存储多个键值对
HMSET key field value [field value...]
# 批量获取哈希表 key 中多个 field 键值
HMGET key field [field...]
# 删除哈希表 key 中的 field 键值
HDEL key field [field...]
# 返回哈希表 key 中 field 的数量
HLEN key
# 返回哈希表 key 中所有的键值
HGETALL key
# 为哈希表 key 中 field 键的值加上增量 n
HINCRBY key field n
```

### 应用场景

#### 缓存对象

```shell
# 存储一个哈希表 uid:1 的键值
> HSET uid:1 name Tom age 15
2
# 存储一个哈希表 uid:2 的键值
> HSET uid:2 name Jerry age 13
2
# 获取哈希表用户 id 为 1 中所有的键值
> HGETALL uid:1
1) "name"
2) "Tom"
3) "age"
4) "15"
```

#### 购物车

涉及的命令如下：

1. 添加商品：HSET cart:{用户id} {商品id} 1
2. 添加数量：HINCRBY cart:{用户id} {商品id} 1
3. 商品总数：HLEN cart:{用户id}
4. 删除商品：HDEL cart:{用户id} {商品id}
5. 获取购物车所有商品：HGETALL cart:{用户id}

## Set

一个集合最多可以存储 2^32 - 1 个元素

### 内部实现

Set 类型的底层数据结构是由 [哈希表](数据结构#哈希表) 或 [整数集合](数据结构#整数集合) 实现的

1. 如果集合中的元素都是整数且元素个数小于 **512**（默认值，**set-maxinset-entries** 配置），Redis 会使用整数集合作为 Set 类型的底层数据结构
2. 如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构

### 常用命令

Set 常用操作：

```shell
# 往集合 key 中存入元素，元素存在则忽略，若 key 不存在则新建
SADD key member [merber...]
# 从集合 key 中删除元素
SREM key member [member...]
# 获取集合 key 中所有元素
SMEMBERS key
# 获取集合 key 中的元素个数
SCARD key
# 判断 member 元素是否存在于集合 key 中
SISMEMBER key member
# 从集合 key 中随机选出 count 个元素，元素不从 key 中删除
SRANDMEMBER key [count]
# 从集合 key 中随机选出 count 个元素，元素从 key 中删除
SPOP key [count]
```

Set 运算操作：

```shell
# 交集运算
SINTER key [key...]
# 将交集结果存入新集合 destination 中
SINTERSTORE destination key [key...]
# 并集运算
SUNION key [key...]
# 将并集结果存入新集合 destination 中
SUNIONSTORE destination key [key...]
# 差集运算
SDIFF key [key...]
# 将差集结果存入新集合 destination 中
SDIFFSTORE destination key [key...]
```

### 应用场景

#### 潜在风险

Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞

#### 点赞

uid:1、uid:2、uid:3 三个用户分别对 article:1 文章点赞：

```shell
# uid:1 用户对文章 article:1 点赞
> SADD article:1 uid:1
(integer) 1
# uid:2 用户对文章 article:1 点赞
> SADD article:1 uid:2
(integer) 1
# uid:3 用户对文章 article:1 点赞
> SADD article:1 uid:3
(integer) 1
```

uid:1 取消了对 article:1 文章点赞：

```shell
> SREM article:1 uid:1
(integer) 1
```

获取 article:1 文章所有点赞用户：

```shell
> SMEMBERS article:1
1) "uid:3"
2) "uid:2"
```

获取 article:1 文章的点赞用户数量：

```shell
> SCARD article:1
(integer) 2
```

判断用户 uid:1 是否对文章 article:1 点赞了

```shell
> SISMEMBER article:1 uid:1
(integer) 0
```

#### 共同关注

uid:1 用户关注公众号 id 为 5、6、7、8、9，uid:2 用户关注公众号 id 为 7、8、9、10、11

```shell
# uid:1 用户公众号 id 为 5、6、7、8、9
> SADD uid:1 5 6 7 8 9
(integer) 5
# uid:2 用户关注公众号 id 为 7、8、9、10、11
> SADD uid:2 7 8 9 10 11
(integer) 5
```

uid:1 和 uid:2 共同关注的公众号：

```shell
# 获取共同关注
> SINTER uid:1 uid:2
1) "7"
2) "8"
3) "9"
```

给 uid:2 推荐 uid:1 关注的公众号：

```shell
> SDIFF uid:1 uid:2
1) "5"
2) "6"
```

验证某个公众号是否同时被 uid:1 和 uid:2 关注：

```shell
> SISMEMBER uid:1 5
(integer) 1
> SISMEMBER uid:2 5
(integer) 0
```

### 抽奖活动

key 为抽奖活动名，value 为员工名称，把所有员工名称放入抽奖箱：

```shell
> SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark
(integer) 5
```

如果允许重复中奖，可以使用 **SRANDMEMBER** 命令：

```shell
# 抽取 1 个一等奖
> SRANDMEMBER lucky 1
1) "Tom"
# 抽取 2 个二等奖
> SRANDMEMBER lucky 2
1) "Mark"
2) "Jerry"
# 抽取 3 个三等奖
> SRANDMEMBER lucky 3
1) "Sary"
2) "Tom"
3) "Jerry"
```

如果不允许重复中奖，可以使用 **SPOP** 命令：

```shell
# 抽取 1 个一等奖
> SPOP lucky 1
1) "Sary"
# 抽取 2 个二等奖
> SPOP lucky 2
1) "Jerry"
2) "Mark"
# 抽取 3 个三等奖
> SPOP lucky 3
1) "John"
2) "Sean"
3) "Lindy"
```
