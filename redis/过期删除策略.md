Redis 可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是 **过期键值删除策略**

## 如何设置过期时间

设置 key 过期时间的命令一共有 4 个：

1. expire \<key\> \<n\>：设置 key 在 n 秒后过期
2. pexpire \<key\> \<n\>：设置 key 在 n 毫秒后过期
3. expireat \<key\> \<n\>：设置 key 在某个秒时间戳之后过期
4. pexpireat \<key\> \<n\>：设置 key 在某个毫秒时间戳之后过期

在设置字符串时，也可以同时对 key 设置过期时间，共有 3 种命令：

1. set \<key\> \<value\> ex \<n\>：设置键值对的时候，同时指定过期时间（精确到秒）
2. set \<key\> \<value\> px \<n\>：设置键值对的时候，同时指定过期时间（精确到毫秒）
3. setex \<key\> \<n\> \<value\>：设置键值对的时候，同时指定过期时间（精确到秒）

使用 TTL \<key\> 命令查看某个 key 剩余的存活时间

如果突然反悔，取消 key 的过期时间，则可以使用 PERSIST \<key\> 命令

## 如何判定 key 已过期

对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个 **过期字典 (expires dict)** 中，过期字典存储在 redisDb 结构中，如下：

```C
typedef struct redisDb {
	dict *dict; // 数据库键空间，存放着所有的键值对
	dict *expires; // 键的过期时间
	...
} redisDb;
```

当查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：

1. 如果不在，则正常读取键值对
2. 如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行对比，如果比系统时间大，那就没有过期，否则判定该 key 已过期

## 过期删除策略

1. [定时删除](#定时删除)
2. [惰性删除](#惰性删除)
3. [定期删除](#定期删除)

## 定时删除

### 做法

在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作

### 优点

可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的

### 缺点

在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好

## 惰性删除

### 做法

不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key

### 优点

因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源。因此，惰性删除策略对 CPU 时间最友好

### 缺点

如果一个 key 已过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好

## 定期删除策略

### 做法

每隔一段时间 **随机** 从数据库中取出一定数量的 key 进行检查，并删除其中过期的 key

### 优点

通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用

### 缺点

1. 内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少
2. 难以确定删除操作执行的时长和频率。如果执行得太频繁，定期删除策略变得和定时删除策略一样，对 CPU 不友好；如果执行得太少，又变得跟惰性删除一样，过期 key 占用的内存不会及时得到释放

## Redis 过期删除策略

Redis 选择 [惰性删除](#惰性删除) + [定期删除](#定期删除) 两种策略配合使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡

### Redis 怎么实现惰性删除

Redis 的惰性删除策略由 db.c 文件中的 expireIfNeeded 函数实现

```C
int expireIfNeeded(redisDb *db, robj *obj) {
	// 判断 key 是否过期
	if (!keyIsExpired(db, key)) return 0;
	...
	// 删除过期键
	...
	// 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除
	return server.lazyfree_lazy_expire ? dbAsyncDelete(db, key) : dbSyncDelete(db, key);
}
```

Redis 在访问或修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：

1. 如果过期，则删除该 key，根据 lazyfree_lazy_expire 参数决定选择异步删除还是同步删除
2. 如果没有过期，不做任何处理，返回正常的键值对给客户端

### Redis 怎么实现定期删除

1. 间隔检查的时间多长？
	在 Redis 中，默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 配置文件 redis.conf 进行配置，配置键为 **hz**，默认值是 hz 10。每次检查数据库并不是遍历过期字典中的所有 key，而是从数据库中随机抽取一定数量的 key 做过期检查
2. 随机抽查的数量是多少
	固定值，由 **ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP** 定义，数值是 20

#### 流程

1. 从过期字典中随机抽取 20 个 key
2. 检查这 20 个 key 是否过期，并删除已过期的 key
3. 如果本轮检查的已过期 key 的数量超过 5 个 (20 \/ 4)，也就是 **已过期 key 的数量** 占比 **随机抽取 key 的数量** 大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查

为了保证定期删除不会出现循环过度，导致线程卡死现象，增加了定期删除循环流程的时间上限，默认不会超过 **25 ms**

## Redis 持久化时，对过期键怎么处理

Redis 持久化文件有两种格式：[[持久化#RDB 快照]](Redis Database) 和 [[持久化#AOF 日志]](Append Only File)

### RDB

分为两个阶段，RDB 文件生成阶段和加载阶段

#### RDB 文件生成阶段

从内存状态持久化成 RDB 文件时，会对 key 做过期检查，过期的键不会被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新的 RDB 文件产生任何影响

#### RDB 加载阶段

1. 如果 Redis 是 **主服务器** 运行模式，在载入 RDB 文件时，会对文件中保存的键进行检查，过期键不会被载入数据库中。所以过期键不会对载入 RDB 文件的主服务器造成影响
2. 如果 Redis 是 **从服务器** 运行模式，在载入 RDB 文件时，无论键是否过期都会被载入数据库。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响

### AOF

分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段

#### AOF 文件写入阶段

当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值

#### AOF 重写阶段

执行 AOF 重写时，会对 Redis 中的键值对进行检查，已过期的键不会被保存到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响

## Redis [主从模式](主从架构)中，对过期键会怎么处理

当 Redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的，即使从库中的 key 过期了，如果有客户端访问从库，仍然可以得到 key 对应的值，像未过期的键值对一样返回。从库的过期键处理依靠主库控制，主库在 key 到期时，会在 AOF 文件里添加一条 del 命令，同步到所有从库，从库通过执行这条 del 指令来删除过期的 key