当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 **Redis 切片集群**（Redis Cluster）方案，将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能

Redis Cluster 方案采用 **哈希槽**（Hash Slot）来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，**一个切片集群共有 16384 个哈希槽**，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：

1. 根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值
2. 再用 16 bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽

## 哈希槽怎么被映射到具体的 Redis 节点上

1. **平均分配**：在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上
2. **手动分配**：可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。需要把 16384 个槽都分配完，否则集群无法正常工作

节点 1 保存哈希槽 0 和 1，节点 2 保存哈希槽 2 和 3

```shell
redis-cli -h 192.168.1.10 -p 6379 cluster addslots 0,1
redis-cli -h 192.168.1.11 -p 6379 cluster addslots 2,3
```

## 集群脑裂导致数据丢失

### 脑裂

在 Redis 主从架构中，部署方式一般是 **一主多从**，主节点提供写操作，从节点提供读操作。如果主节点的网络突然发生问题，与所有从节点都失联了，但是和客户端的网络是正常的，这时客户端不知道 Redis 内部已经出现了问题，还在照常向失联的主节点写数据，此时这些数据被旧主节点缓存在缓冲区中，因为主从节点之间的网络问题，这些数据无法同步给从节点

这时，哨兵也发现主节点失联了，便认为主节点挂了（但实际上主节点正常运行，只是网络出了问题），于是哨兵就会在从节点中选举出一个 leeder 作为主节点，这时集群就有两个主节点了——脑裂出现了

然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，就会把旧主节点降级为从节点，然后这个从节点会向新主节点请求数据同步，**因为第一次同步是全量同步的方式，此时的从节点会清空自己本地的数据，然后再做全量同步。所以，之前客户端在失联期间写入的数据就会丢失，也就是集群产生脑裂数据丢失的问题**

### 解决方案

当主节点发现从节点下线或者通信超时的总数量达到阈值时，那么禁止主节点进行写数据，直接返回错误给客户端

在 Redis 的配置文件中有两个参数我们可以设置：

1. min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据
2. min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据


