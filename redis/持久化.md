## AOF 日志

redis 每执行一条写操作命令，就把该命令追加写入到 aof 日志中，这种保存写操作命令到日志的持久化方式，就是 redis 中的 AOF(Append Only File) 持久化功能，注意只会记录 **写操作** 命令，**读操作命令** 是不会被记录的。

在 redis 中 AOF 持久化功能默认是 **不开启** 的，需要修改 **redis.conf** 配置文件中的以下参数：

```shell
// redis.conf
appendonly     yes              // 表示是否开启AOF持久化(默认 no，关闭)
appendfilename "appendonly.aof" // AOF持久化文件的名称
```

### 先执行再记录的好处

1. 避免额外的检查开销
2. 不会阻塞当前写操作命令的执行

### 潜在风险

1. 执行写操作命令和记录日志是两个过程，当 redis 还没来得及将命令写入硬盘时，服务器发生宕机，这个数据就会有 **丢失的风险**
2. 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给 **下一个** 命令带来阻塞风险，因为执行与记录这两个操作都是在 **主进程** 中完成的

### 写入 AOF 日志的过程

[img 写入AOF日志的过程](../images/写入AOF日志的过程.webp)

1. redis 执行完写操作命令后，会将命令追加到 **server.aof_buf** 缓冲区
2. 然后通过 **write()** 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据 **并没有** 写入到硬盘，而是拷贝到了内核缓冲区 **page cache**，等待内核将数据写入硬盘
3. 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定

### 3 种写回硬盘的策略

在 **redis.conf** 配置文件中的 **appendfsync** 配置项有以下 3 种参数可填

1. **Always** ：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘
2. **Everysec** ：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后 **每隔一秒** 将缓冲区的内容写回到硬盘
3. **No** ：不由 redis 控制写回硬盘的时机，转交给操作系统控制

这 3 种写回策略都无法完美解决 **主进程阻塞** 和 **减少数据丢失** 的问题，原因如下：

1. **Always** ：可以最大程度保证数据不丢失，但是由于每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以不可避免会影响主进程的性能
2. **No** ：交由操作系统决定何时将 AOF 日志内容写回硬盘，相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据
3. **Everysec** ：折中的方式，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失

根据业务场景进行选择

1. 高性能选择 No 策略
2. 高可靠选择 Always 策略
3. 允许数据丢失一点，又想性能高，选择 Everysec 策略

[img redis写回策略总结](../images/redis写回策略总结.webp)

### AOF 重写机制

AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到 **新的 AOF 文件**，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件

### AOF 后台重写

Redis 的重写 AOF 过程是由后台子进程 **bgrewriteaof** 来完成的，这样做有两个好处：

1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程
2. 子进程带有主进程的[数据副本](#子进程如何拥有主进程的数据副本)，不用通过加锁来保证数据安全

#### 子进程如何拥有主进程的数据副本

主进程在通过 **fork** 系统调用生成 **bgrewriteaof** 子进程时，操作系统会将主进程的 **页表** 复制一份给子进程，两者的虚拟空间不同，但其对应的物理空间是同一个

这样能够 **节约物理内存资源**，页表对应的页表项的属性会标记该物理内存的权限为 **只读**

##### 写时复制

不过，当父进程或子进程在向这个内存发起写操作时，CPU 就会触发 **缺页中断**，这个缺页中断是由于违反权限导致的，然后操作系统会在 **缺页异常处理函数** 里进行 **物理内存的复制**，并重新设置其内存映射关系，将父子进程的内存读写权限设置为 **可读写**，最后才会对内存进行写操作，这个过程被称为 **写时复制(Copy On Write)**

但是，写时复制只会复制主进程修改的物理内存数据，没有修改的物理内存还是与子进程共享的

#### 导致阻塞父进程的两个阶段

1. 创建子进程的过程中，由于要复制父进程的页表等数据结构，阻塞的时间和页表的大小有关，页表越大，阻塞的时间也越长
2. 创建完子进程后，如果子进程或父进程修改了共享数据，就会发生[写时复制](#写时复制)，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长

#### AOF 重写缓冲区

在重写 AOF 期间，当 redis 执行完一个写命令后，它会 **同时将这个写命令写入到 AOF 缓冲区和 AOF 重写缓冲区**

## RDB 快照

redis 提供了两个命令来生产 RDB 文件，分别是 **save** 和 **bgsave**，区别在于是否在 **主线程** 里执行：

1. 执行 **save** 命令，就会在主线程生成 RDB 文件，**会阻塞主线程**
2. 执行 **bgsave** 命令，会创建一个子进程来生成 RDB 文件，可以 **避免阻塞主线程**

redis 还可以通过配置文件的选项实现每隔一段时间自动执行一次 **bgsave** 命令：

```shell
save 900 1 // 900秒内，对数据库进行了至少1次修改
save 300 10 // 300秒内，对数据库进行了至少10次修改
save 60 10000 // 60秒内，对数据库进行了至少10000次修改
```

### 执行快照时，数据能被修改吗

redis 在执行 bgsave 时采用了[写时复制](#写时复制)技术，发生写时复制后，RDB 快照保存的是 **原本的内存数据**，而主线程刚刚修改的数据，则需要等到下一次 bgsave 快照

如果系统恰好在 RDB 快照创建完毕后崩溃，那么 redis 将会丢失主线程在快照期间的修改

### 极端情况

如果所有的共享内存都被修改，则此时的内存占用是原先的 **2 倍**

## 混合持久化

redis4.0 提出的 **混合使用 AOF 日志和内存快照**，也叫 **混合持久化**

如果要开启混合持久化功能，可以在 redis 配置文件中修改如下配置

```shell
aof-use-rdb-preamble yes
```

### 混合持久化的工作过程

混合持久化工作在 **AOF 日志重写过程**

当开启混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程的操作命令会被记录在 **重写缓冲区**，重写缓冲区的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后会通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的 AOF 文件

