在更新数据时，不更新缓存，而是删除缓存中的数据，到读取数据时，发现缓存中没有数据后，再从数据库中读取数据，更新到缓存中

## 细分为读策略和写策略

1. **写策略**
	1. 更新数据库中的数据
	2. 删除缓存中的数据
2. **读策略**
	1. 如果读取的数据命中了缓存，则直接返回数据
	2. 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户

## 先删除缓存还是先更新数据库

1. **先删除缓存，再更新数据库**：在 **读 + 写** 并发的时候，会出现缓存和数据库的数据不一致的问题，但是可以采用 **延迟双删** 的方式解决

```shell
# 删除缓存
redis.delKey(X)
# 更新缓存
db.update(X)
# 睡眠
Thread.sleep(N)
# 再次删除缓存
redis.delKey(X)
```

2. **先更新数据库，再删除缓存**：理论上会出现数据不一致的问题，但实际上出现概率不高，因为缓存的写入通常远快于数据库的写入，所以可以保证数据一致性

## 先更新数据库，再删除缓存，怎么解决删除失败的问题

### 重试机制

引入 **消息队列**，将删除缓存要操作的数据加入到消息队列，由消费者操作数据

1. 如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存。如果重试超过一定次数还没有成功，就需要向业务层发送报错信息
2. 如果缓存删除成功，就要把数据从消息队列中移除，避免重复操作

### 订阅 MySQL binlog，再操作缓存

使用 Canal 模拟 MySQL 主从复制到交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Biglog 字节流后，转换为便于读取到结构化数据，供下游程序订阅使用

[img Canal工作流程](../images/canal工作流程.webp)
